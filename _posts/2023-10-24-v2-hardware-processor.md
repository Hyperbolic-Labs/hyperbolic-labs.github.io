---
layout: post
title: V2 Hardware - Processor
---

One of the first design decisions I made was the main processor, since a lot of subsequent decisions originate here. Being familiar with the STM32 family from other projects, I started shopping around for a general purpose MCU with relatively low cost. More specifically, I wanted something with USB support for easy firmware updates, plenty of peripherals, and a decent amount of flash/ram. After shopping around I eventually landed on the STM32F411 offering, which had everything I needed and not much more.  The Cortex M4F processor runs at a maximum of 100MHz, with 512K flash/128K SRAM. This is probably overkill for this use case but it's worth the peace of mind sometimes, especially during the experimentation phase. Current consumption is significantly less than an ESP32, right around 25mA at 100MHz. For programming the MCU, I added pads for connection to an ST-Link programmer in addition to a micro USB port. This makes it easy to upload firmware fast via the debug port, and still have the USB available for a virtual COM port. This processor can run from the internal RC oscillator, but needs an external crystal for reliable USB communication. I settled on an 8MHz crystal from NDK that's rated for operation down to -40C. In the previous design, I had issues getting the ESP32's crystal oscillator to reliably start. In retrospect, I'm pretty sure I chose incorrect values for the crystal loading capacitors. Luckily, ST has an informative [appnote](https://www.st.com/resource/en/application_note/an2867-guidelines-for-oscillator-design-on-stm8afals-and-stm32-mcusmpus-stmicroelectronics.pdf) for choosing the correct values. Maintaining a stable system clock is also critical for parsing GPS data. A clock mismatch of only a few percent is enough to cause GPS checksum errors. Future designs may be able to circumvent the need for a crystal with automatic baud rate detection, but for this version I need something reliable.

Watchdog
Protecting the system from an unexpected software lockup is important for increasing system reliability. Luckily, the STM32 platform contains a dedicated watchdog timer peripheral that must be periodically 'tapped'. The watchdog is clocked via the LSE internal clock to guard against the scenario where the main HSE/HSI oscillator fails. Once started, this mechanism is very robust against adverse conditions, but still has a critical weakness. Initialize watchdog first, or after other peripherals? If a hardware failure causes some peripheral to take longer than expected, getting stuck in an endless reboot cycle is non-ideal. Initializing the watchdog timer after other peripherals leaves the system vulnerable to getting stuck in an undefined state. There isn't a perfect answer to this dilemma, but I lean toward the latter option. A 'smart' way to circumvent this would be to use a boot failure counter that limits the maximum number of cyclic reboots, maybe even the ability to disable failed non-critical components. On subsequent hardware versions, I'd like to move the watchdog off chip entirely which overcomes this potential issue. 
