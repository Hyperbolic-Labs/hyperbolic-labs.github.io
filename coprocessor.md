Why did I start this project?
----------------------------------------
I've been always been fascinated with GPS trackers, and high altitude ballooning comes with wide array of engineering challenges that I find appealing. Of course, there are manytried-and-true platforms that have been developed over the years with varying degrees of utility. Most of the well documented examples that exist on the internet use APRS orWSPR networks for relaying telemetry data, and for good reason. These networks are wide reaching and the frequencies in use enable payload tracking across the globe, and lets users track the position of their balloon live via a web interface such as SondeHub. However there are a few ideas of my own that I haven't seen yet, so I'd like to documentmy design process for those who find it insightful. I'll go into all the important considerations that go into designing a high altitude tracking system from the ground up,and hopefully others can learn from my many mistakes.As with any project, it's critical to have concrete goals before you begin. Since I began this project 2 years ago the goals have morphed over time, but the same core concepts remain.

Goal #1:    Detachable Payload
----------------------------------------
Ever since stumbling across Dave Ackerman's excellent series on LoRa tracking, I've wanted to experiment with bidirectional communication. One in particular is the the ability to detach the payload from the balloon if necessary. I happen to live near the ocean, and occasionally the wind direction will blow towards the coast which would make payload retrieval impossible. The ability to send a detach command to the payload is a great way to prevent it from drifting too far.

Goal #2:    Dynamic Configuration
----------------------------------------
Of slightly less importance, I'd like the ability to change mission settings on the fly. There are dozens of things that can go wrong during a high altitude mission, and a singlecomponent failure can ruin the chances of recovering the payload. Received signal strength too low? Update the LoRa modulation parameters to get more range. Make a mistake in the pre-flight configuration? Fix it after the fact, etcetera.

Goal #3:    Flexible Software Platform
----------------------------------------
As a software engineer, having a polished and reliable firmware is something that carries a lot of weight for me. My goal is to create a clean, easily portable codebase that others can modify for easily implementing their own ideas, hopefully lowering the barrier to entry for this hobby. A lot of inspiration has been taken from the Meshtastic project,with an abstraction layer between the application and the hardware it runs on. In the future, I'd like to edit only a few implementation files whenever I develop new trackinghardware.

Goal #4:    Off-Grid Tracking
----------------------------------------
Where I live, mountains significantly limit cell coverage, meaning that the chase vehicle doesn't have a reliable internet connection. In order to maximize the probability of finding the payload after it lands, I'm implementing a custom point-to-point protocol over LoRa. This approach comes with its own set of downsides like not having dozens ofredundant receive stations; however, I think most of these drawbacks can be overcome with some smart design choices. Reiterating, this HAB platform is realistically only suitedfor payloads that will be retrieved.




Floatini Nano V2 Hardware Overview
----------------------------------------
Having learned from some of my mistakes with V1, I got started on version 2 hardware. The main goals of this version were power reduction and easier software development, and this led to an almost complete redesign. I also planned on submitting this design for JLCPCB's board assembly service, which meant selecting parts from their onlinecatalog. 

Processor
---------------------------------------
One of the first design decisions I made was the main processor, since a lot of subsequent decisions originate here. Being familiar with the STM32 family from other projects,I started shopping around for a general purpose MCU with relatively low cost. More specifically, I wanted something with USB support for easy firmware updates, plenty of peripherals, and a decent amount of flash/ram. After shopping around I eventually landed on the STM32F411 offering, which had everything I needed for the lowest price. In addition, this MCU has been around for awhile and has lots of example code out there. The Cortex M4F processor runs at a maximum of 100MHz, with 512K flash/128K ram. This is probably overkill for this use case but it's worth the peace of mind sometimes, especially when developing untested firmware. Also, current consumption is significantly lessthan an ESP32, right around 25mA at 100MHz. For programming the MCU, I added pads for connection to an ST-Link programmer in addition to a micro USB port. This configurationmakes it easy to upload firmware fast via the debug port, and still have the USB available for a virtual COM port.This processor can run from the internal RC oscillator, but needs an external crystal for reliable USB communication. I settled on an 8MHz crystal from NDK that's rated for-40C. In the previous design, I had issues getting the ESP32's crystal oscillator to reliably start. In retrospect, I'm pretty sure the crystal loading capacitors werecalculated incorrectly. Luckily, ST has a very app note for choosing the correct capacitors: https://www.st.com/resource/en/application_note/an2867-guidelines-for-oscillator-design-on-stm8afals-and-stm32-mcusmpus-stmicroelectronics.pdfHaving a stable MCU clock is also critical for parsing GPS data. A clock mismatch of only a few percent is enough to cause GPS checksum errors, and subsequently no position data. Future designs may be able to circumvent the need for a crystal with automatic baud rate detection, but for this version I need something reliable.On the ESP32 platform, storing nonvolatile settings is easily managed with the Preferences library, which provides an abstraction layer for storing variables in flash memory.The STM32F411 processor unfortunately doesn't have enough flash memory to implement nonvolatile storage with adeqate wear leveling. This problem is easily solved by addingan external I2C EEPROM, which are very cheap. I went with a M24C64 EEPROM with 8Kbyte capacity, which should be plenty for what I will need. The M24C series has a writeendurance of 4 million cyles which means I don't have to worry about implementing a wear leveling algorithm, another plus. Version 1 of the HAB tracker had an SD card connector, which served dual purpose as a storage medium for images and datalogs. Since this version doesn't integrate a camera,inexpensive NOR flash is the better choice. It's more reliable, consumes significantly less power, and has a smaller PCB footprint. W25Q64 from Winbond has 8Mbyte capacity,which works out to just over 9 hours of log data, assuming a 256 byte record once per second.

New Power Supply
----------------------------------------
After re-reviewing my low temperature battery options, I discovered that Energizer's AA lithium batteries are a better choice due to their better energy density compared to a CR123A. The downside is that the boost converter will have to work a little harder since the nominal voltage is ~1.4V instead of 3.0V. In practice, this means I need to finda boost converter capable of operating down to 0.8V or less in order to extract as much energy as possible. There aren't too many boost converters available that can workthis low. Another thing I had to watch out for was minimum startup voltage. Several boost converters I was considering needed a minimum of 1.8V to reliably start, and then could operate much lower due to internal bootstrap. Eventually I found TPS61021A from Texas Instruments. This chip can start up from an input as low as 0.5V, and can deliver plenty of power. Conveniently it operates at a much higher frequency than the old MCP1640 so I can use a much smaller inductor. Like the V1 design, the boost converter output is filteredthrough an LDO that cleans up some of the noise. To reduce power consumption at low load currents, most switching converters transition to psuedo-pwm mode, only charging up theoutput capacitors when the output voltage drops too low. This manifests a low freqency (~kHz) sawtooth waveform imposed on the output. For digital circuits this usually isn'tan issue, but this will negatively impact the GPS and analog sensor readings. I went with a 3.3V TPS7A20 regulator which has excellent PSRR and noise characteristics, and doesn't add much cost. I configured the boost converter output for 3.6V which should give the LDO just barely enough headroom to adequately filter out noise. 5V USB power is fed in viaa diode to this 3.6V node; this created some issues that I'll detail later. 

Sensors
----------------------------------------
Barometric pressure sensor: DPS310Accelerometer: LIS2DHGPS Receiver: MAX-M10SNTC ThermistorCurrent sensor: INA199During the time I was choosing components, JLCPCB didn't have many options for pressure sensors. I was impressed with the noise level of the BMP581 sensor in the first design, but this chip wasn't in stock at JLCPCB. After a little research I settled on the DPS310 sensor from Infineon, in part thanks to the very helpful chart made by a fellow Hackaday user: https://hackaday.io/project/86912-explog-exploration-logger/log/123294-choosing-the-right-sensorsDPS310 stacks up very well compared to the Bosch sensors, and happened to be available from JLCPCB at a very reasonable price. On a whim, I decided to add a low cost accelerometer to the design. This will let me experiment with more accurate burst and landing detection. At the moment I don't know how how useful these features will actually be, but in the future it could be used to implement a low power mode that wakes when movement is detected.For measuring battery current, I went with a INA199 current sense amplifier. This chip consists of a low offset op-amp with integrated differential gain resistors, which reducesthe overall component count. Battery voltage is sensed via a simple voltage divider. As a side note, the STM32's positive ADC reference is VDD, which is 3.3V. In order to get accuratereadings, the mcu first reads the internal voltage reference to figure out the exact voltage of VDD. It then uses this number to accurately scale the current and voltage measurementsappropriately.Ambient air temperature is a key datapoint to collect during a mission, and one of the simplest ways to acccomplish that is with an thermistor. They're low cost and onlyrequire 1 pin from the MCU. The processor and pressure sensor both have internal temperature sensors, which version 1 planned on using. However, since they are board mounted, thosesensors won't give an accurate air temperature reading, which is critical for computing barometric altitude. A thermistor can also report temperatures below -40C, which is the lower limit for most silicon based sensors. Ublox still makes the most reliable GPS receivers on the market, and MAX-M10S is a big improvement over the older MAX-M8 chip. Power consumption is reduced significantly and now hasa builtin LNA for better passive antenna performance. I've always been impressed with how well this receiver works so it's a no-brainer for me. Since GPS receivers are sensitive tohigh frequency harmonics, I added series resistors to the UART and PPS pins which limit the rise/fall times. I also kept the W3011 passive antenna because it's always served me wellin past projects.The onboard sensors cover all the basic high altitude metrics, but in the likely event that additional sensors are needed I provisioned a QWIIC connector for additional I2C devices.

Miscellaneous
--------------------------
I kept the SX1262 radio module from NiceRF from the previous design, mostly because it includes a TCXO. LoRa modules that don't have a TCXO are typically forced to operate at higherbandwidths because of temperature-induced frequency drift. This is undesirable because higher bandwidths severely limit the maximum transmission range. Given the complete failure of the pcb-trace cutdown mechanism of V1, I had to come up with a completely different approach that had a better chance of working. Perusing Aliexpress, I disovered some tiny ceramic heating elements that seemed like they would work perfectly. They're made of a small coil of nichrome wire enased in a hollow ceramic core. I plan on feeding the end of the balloon tether through center of this heating core, which is held in place with a drop of candle wax. When power is sent through the heater core, the elementsoftens the wax to let the string pull out, severing connection to the balloon. My main concern with this approach is whether the battery will be able to supply enough power to melt the wax at low temperatures. I will probably experiment with insulation techniques around the heating core so the element doesn't lose too much heat to the surrounding air. Elementpower is enabled via a low side N channel mosfet which is driven by the MCU.After landing, I anticipate degraded tracker GPS accuracy if it doesn't land upright. I provisioned two MCU pins to drive a piezo buzzer to make recovery easier. These pins will bedriven out of phase so the piezo element sees 6.6V peak to peak. For development and debugging purposes there are 4 green LEDs which provide indication of radio transmit/receive status, GPS fix, and processor usage. I also added a micro slide switchas an input to the MCU, which allows software-configured functionality. For my purposes, I will probably assign this switch to set the current tracker mode: in one position, the trackeris in 'mission' mode, and continously records and transmits data. In the opposite position, the tracker is configured to be in 'debug' mode, and doesn't record telemetry data.

Telemetry Considerations
--------------------------
One of the main features I want from this tracker is bidirectional radio communication. With this in mind, I designed the telemetry protocol to support on-the-fly configuration via uplink commands. This also enables the chase vehicle to pick and choose which data the tracker sends. Since the radio modem's transmit power is relatively low, I've come up with a plan for when radio communication is lost. Since radio parameters are dynamically configurable, there isa potential to get into an unrecoverable state if there's an issue with the configuration process. A simple solution to this is via implementation of 'fallback' state for both radios.If either radio hasn't received a valid packet from the other for a certain duration, both will revert to a hardcoded set of frequency, bandwidth, and spread factor. These fallback parameters should be chosen for long range, low data rate in case the 'normal' radio parameters doesn't have enough range. Finally, I've decided to have the ground station query telemetry packets from the tracker during normal operation (both radios can 'hear' each other). If the radio link fails and both revert to the fallback state, the tracker will beginbroadcasting telemetry packets on its own. I'm doing it this way is for the following reasons: If the communication link is lost for a short time (tracker obstructed by buildings, terrain, etc), it will be wasting transmit power unnecessarily. Querying the tracker, however, doesn't have this downside since it will only transmit telemetry if and when it receivesa request. Then, if communication is totally lost (fallback radio parameters), the tracker can blindly send out telemetry. This is to guard against circumstances where the groundstation's transmitter (or tracker's receiver) is damaged or inoperable. The flow chart below details the tracker's internal state machine.

Converting Atmospheric Pressure to Altitude
----------------------------------------------
Using barometric pressure and temperature is an easy way to estimate altitude, but this method of altitude measurement often suffers from relatively large offset errors that doesn'taffect GPS. During my research, I found that most examples of altitude estimation in code were using hypsometric formula. While simple, this formula has accuracy issues at the typicalheight many HAB flights reach. After lots of digging, I came across an invaluable paper with a proposed new formula that should be more accurate at higher altitudes: linkThis equation more accurately models the temperature lapse rate of the atmosphere, which is usually implemented as a piecewise linear approximation when using the hypsometric version.Weather induced local pressure deviations can also be responsible for large changes in the reported altitude, and I imagine much of this error can be compensated by measuring local atmospheric temperature. After my first successful launch, I will compare the altitude from both equations with the reported GPS altitude to see definitively which one has the edge. Algorithm Tangent:Out of curiosity I decided to benchmark the altitude calculation function and discovered that a single iteration took over 20,000 CPU cycles to complete. To me this seemed very inefficient, especially since the STM32's processor includes a floating point unit. Digging deeper, I found that the majority of the processing time was taken up with the exponential pow() operation. However, the way the formula is constructed makes for a near worst-case scenario for the pow() computation. The pressure ratio is used as the base operand, and ishighly sensitive to significant digits. This is compounded by raising this base to a floating point exponent which further increases reliance on floating point precision. When theseformulas are implemented with powf() (the 32bit float version of pow()), floating point precision alone reduces altitude resoution to several meters. But there is a way to kill two birds with one stone: interpolation. So I wrote a cubic interpolation class that accurately models the relationship of pressure ratio (p/p0) to altitude for a given exponent value,which happens to be relatively constant. In the end, I was able to reduce the computation time from ~250uS down to ~2uS all while improving altitude resolution. 250uS isn't that muchin the grand scheme, but I can easily see this computation time increasing by an order of magnitude if the processor doesn't have a floating point unit. Unfortunately, the barometric pressure sensor I chose for Floatini V2 Nano is only specified down to ~30kPa. This will probably cause the altitude estimations past 30,000ft to havelarge errors. There a few sensors such as MS5607 and MS5611 that can measure much lower pressures, but I omitted them from this hardware version for cost reasons. This means that above 30,000ft the GPS will be the altitude source. I'm guessing the barometer will still give valid readings below 30kPa but are likely outside the calibration range. With thisassumption, I will be testing out an experimental complementary filter which fuses GPS and barometeric altitude measurements. GPS is used as a noisy, zero-offset source and barometerreadings are used to measure short term altitude variations. By experimenting with different filter cutoff frequencies I should be able to compensate for imperfect barometerlinearity, without the noise associated with GPS.

Data Logging
--------------------------
Floatini V2 Nano makes use of a 64Mbit NOR flash chip for recording mission data. NOR flash is inherently more power efficient than NAND, but has significantly less capacity. Forthis reason I decided against the virtual filesystem route. There are some great open source filesystem libraries specifically for embedded, but it seemed like too much overhead for this use case, especially since nearly all accesses will be sequential. The flash chip is partitioned into two sections, log data and events. For now, log entries are composedof a packed 256 byte block of all datum values, although I may update this to support 512 byte entries in the future. NOR flash architecture dictates that individual bytes may onlybe programmed once until erasure (some chips allow writing individual bits within a byte from 1 to 0 but this gets complicated). The difference in programming time between one byte and a full page is generally insignificant, so log entries are multiples of 256 for maximum efficiency. A continuous datalog captures a large amount of diagnostic data, but doesn't always capture events that happen inside the log interval. In service of this, there is a second sectionof flash dedicated for event logging. Timestamping events paints a more complete picture of what was going on at the time, so I opted for a time-delta approach with 1ms resolution.Each event record consists of a 2 byte time delta (mS since previous event) and single byte which is the event ID. If there hasn't been an event in 65.535 seconds, a null 'padding' event is generated to handle the overflow condition. It takes 85 records to fill a page of flash, with 1 byte to spare, which accounts for up to 90 minutes. It's difficult to pre-emptively estimate how many events will be generated, but let's assume a worst case scenario of 1 event per second. Then one flash page will only last 85 seconds, so a 256kB flash partition offers 24 hours of recorded events -- more than enough for this application.On boot, the next flash address in sequence for data and event records isn't known, and must be discovered by reading through the flash. In the code, I've implemented a simple binary search that looks at the first byte of a page to determine if it has already been written to, since flash will always erase to all 0xFF. Binary search is significantly faster than a linear search, reducing flash parsing from a worst case of 1000ms down to 10ms. 

Watchdog
--------------------------
Protecting the system from an unexpected software lockup is important for increasing system reliability. Luckily, the STM32 platform contains a dedicated watchdog timer peripheralthat must be periodically 'tapped'. The watchdog is clocked via the LSE internal clock to gaurd against the scenario where the main HSE/HSI oscillator fails. Once started, this mechanism is very robust against adverse conditions, but still has a critical weakness. Initialize watchdog first, or after other peripherals? If a hardware failure causes someperipheral to take longer than expected, getting stuck in an endless reboot cycle is non-ideal. Initializing the watchdog timer after other peripherals leaves the system vulnerableto getting stuck in an undefined state. There isn't a perfect answer to this dilemma, but I lean toward the latter option. A 'smart' way to circumvent this woulb be to use a bootfailure counter that limits the maximum number of cyclic reboots, maybe even the ability to disable failed non-critical components. On subsequent hardware versions, I'd like to movethe watchdog off chip entirely which overcomes this potential issue. 

Nonvolatile Data
--------------------------
I decided to incorporate an I2C EEPROM for storing settings and other non-volatile data. A more cost constrained design could easily move data storage onto the NOR flash chip or even the STM32's internal storage, but I wanted a dedicated chip for a few reasons. The first being increased write endurance compared to flash technology. The M95C64 chip I chose for this design is rated to 4 million cycles. This equates to a minimum lifetime of over 1000h with 1 write per second, making the consideration of wear leveling irrelevant.Secondly, during the firmware development process a decent length of time is spent getting the data partitioning right. Making the settings part of the same storage medium adds further software complexity. In retrospect I think I2C is the wrong mode of communication though. While debugging some issues in the eeprom driver, I managed to get the I2C bus stuck into a arbitration lost (ARLO) state, which apparently is only recoverable via power cycle after further investigation. I eventually discovered this bus state was caused by a bug in the I2C driver code I had written, but the point still stands. The I2C bus is also more susceptible to single device failures. If a single I2C device on the bus decides to erroneously pull SDA or SCL low, the entire bus becomes inoperable. In the next version, I'll be going with an SPI EEPROM instead for these reasons. 

Battery monitoring
--------------------------
Measuring battery voltage is easily achieved via a simple voltage divider which the STM32's internal ADC can read directly, but measuring battery current requires a few externalcomponents. I opted for a INA199 low offset differential amplifier chip, which measures low side battery current. Usually it's preferable to measure high side current, but I didn'twant the battery to get drained by unnecessarily by the gain resistors. The INA199's input common mode voltage extends down to -0.1V, so I was able to position the current senseresistor below ground to reduce design complexity. I chose the combination of a 10mOhm resistor and the amplifier variant with a gain of 50. The STM32's positive ADC reference is 3.3V, which means this setup can theoretically measure up to 6.6A. Looking back I should have chosen the -A3 variant with a gain of 200, but at the time I massively overestimated the maximum battery current draw. 

Temperature Sensor
-------------------------
For measuring ambient air temperature, I chose a leaded NTC thermistor approach instead of a digital IC. Thermistors exhibit a non-linear, yet predictible change in resistanceagainst temperature. While somewhat primitive, they can measure a much wider range compared to most digital temperature sensors. Also since the sensor is located off PCB in this configuration, ambient airaccuracy will be a little better. At upper levels of the atmosphere, the air is much thinner and likewise has much higher thermal conductivity. Because of this, sensors exposed todirect sunlight will read slightly higher temps than those in the shade. Supporting hardware for thermistors is minimal, just a reference resistor and reference voltage. Luckily the STM32's ADC os referenced tp VDD, which the thermistor-resistor voltage divider can draw from. In this way, ADC measurements can be translated directly into a ratio between reference resistance and thermistor resistance. Once the sensor's resistance has been calculated, this value gets plugged into the Hart-Steinhart formula, which NTC thermistorsclosely approximate. There are two key specifications thermistors have: resistance at 25C, and a Beta parameter which describes the approximate 'slope' of resistance vs temperature.More specifically, beta can be calculated via the following formula:

LoRa Radios
--------------------------
All communication to the tracker happens via a SX1262 radio transceiver module. I chose NiceRF module since they offer a 12x16mm module with TCXO, which has a huge impact on sensitivity during extreme temperature changes. The sensitivity of the LoRa receiver is inversely proportional to the bandwidth selected, and choosing a narrower bandwidth reducesthe peak transmit current, improving battery life. Floatini V3 Nano

Watchdog Coprocessor
--------------------------
After much consideration, I decided to include a separate MCU to this design that acts primarily as a analog front end and watchdog forthe RAK3172 LoRa module. This is in part due to the limited I/O ports of the LoRa module and also for more design flexibility. One microcontrollerthat caught my eye is the MSPM0L130x series from Texas Instruments. It's a Cortex M0 processor with lots of builtin analog peripherals that eliminatethe need for a lot of discrete components, and can be found for less than $0.70 in quantity. 

Current sensor design
--------------------------
Having an accurate measurement of battery current provides another valuable datapoint that I'd like this design to have. The most cost effective way of sensing current inthis instance is to incorporate the builtin PGA of the MSP. Using the internal PGA instead of an external op amp has some real accuracy benefits that matter in this case. While the on-chip gain resistors may not have the highest initial accuracy, they have excellent temperature drift characteristics. 

Analog Frontend
--------------------------
Due to the LoRa module's limited GPIOs, I opted for an inexpensive ADS1115 discrete I2C ADC. This chip is super handy because it integrates a builtin PGA, eliminating the needfor a current sense amplifier for measuring battery current. 3 channels are dedicated for monitoring the supply voltages, Vbat, Vsys, and Vdd. The 4th channel is used to measurebattery input current

Release Mechanism
--------------------------
After trying several ideas I had around a heater-based cutdown mechanism, it was clear that this approach just wasn't going to work reliably at low temperatures. The batterycan only supply a limited amount of current, and I found that 1W of power just wasn't enough melt through a polymer-based balloon tether. A micro sized solenoid could work,but most weren't designed to operate from a single AA cell, and most significantly increased the total weight. The minimum energy required to release the balloon is actuallyvery low, and most solenoids have way more pull strength than is necessary. Given these facts, I decided to come up with my own purpose-built magnetic release that weighsalmost nothing and requires very little power to operate. To accomplish this I'll be using an unshielded inductor with a ferrite core, which is mounted to a flex PCB. The flexPCB has a long tab which gets folded into a loop with a small Neodymium magnet on the end. When current is run through the inductor, an opposing magnetic field is generated which repels the magnet, releasing the balloon. This mechanism should be more reliable and only use a fraction of the energy used by the heater method.It's suprisingly difficult to search for unshielded inductors with the right geometry for this application, since shielded inductors are always better for most use cases.However, I found the LPO2506 series from Coilcraft to be nearly perfect. They are constructed from ceramic with an inner ferrite core which is about 5mm in diameter, and athickness of 1.5mm. The magnetic specs aren't listed in the datasheet, but most ferrites saturate in the 0.25-0.4T range. This means by choosing a magnet with a similar fluxdensity, the attraction force of the magnet can be roughly nullified by running the inductor near saturation. In addition, since the inductor will be pre-biased 'against' the field generated by the coil, it can be pushed past it's normal saturation current. This in turn means that not only will the magnet lose attraction to the ferrite, but it willactually see a repulsive force. Using the magnet calculator from K&J magnetic's website, I calculated the surface flux density of a 5x1mm disc magnet to be ~0.25T. This works out great, since this means the ferrite core will be just barely saturated in the opposite direction (or close to it). Assuming the core saturates at 0.25T, this means all we have to do is pass through the 'normal' (unbiased) saturation current through the inductor to bring the net field close to zero. By somewhat arbitrarily choosing the 220uH inductor from this series, the DC resistance is listed as 3.7ohms. Assuming a battery voltage of 1.0V this works out to 0.24A through the inductor, just barely past the listed saturation current. In short,when 1.0V is applied to the inductor, the attraction force of the magnet should be close to zero, releasing the balloon. Of significant importance is the consideration of maximum holding force this mechanism can withstand. K&J magnetics also has a pull force calculator, and a 5x1mm disc magnet has a axial pull strength of 0.49lbs. The shear pull strength of a magnet happens to be about half of its axial pull strength as detailed here: https://www.kjmagnetics.com/blog.asp?p=shear-force.Meaning, this magnet will be able to withstand ~110g of vertical pull from the balloon (even without considering friction between magnet and inductor). I think this should be plenty of margin for this mechanism to work without releasing prematurely.There is one potential downside to this configuration however. The maximum payload weight is fundamentally limited by inductor selection. Due to core saturation, increasing magnetsize doesn't increase holding strength: it only reduces the repulsion force when the inductor is powered. Payloads over 110g would need an inductor with a larger cross sectional area or be forced to use a different release mechanism altogether.vinp = R2 (vdd-vlow)/(R1+R2+Rsw)Measure op amp output voltage when lower vref is bat-, record reading. This value is pga offset voltage times pga gain error. offset voltage sum of op amp (internal) os PLUSerror in vref voltage divider. We don't care if Rsw changes with temperature, as it only manifests as a Vos error in the end. calibration requirements:- two gnd-referenced voltages needed (for offset and pga gain cal)- both ref voltages must be >0V- pga in- can be muxed to groundvdd measurement voltage:    (3.0/3.2768)*1.4 = 1.28173828125upper, lower: 0.030000, 0.012000Errors, 1: 0.23%, 2: 0.33%, 3: 0.47%, 4: 0.32%, total: 0.03%R1: 232000.000000, R2: 169000.000000, R3: 2430.000000, R4: 1620.000000R1: 0.572769, R2: 0.417232, R3: 0.005999, R4: 0.004000

What does this platform offer?
---------------------------------
While a high altitude balloon can be constructed with off the shelf parts, Floatini combines all these basic components into a lightweight, self-contained unit. Thisincreases reliablily significantly by eliminating wires. Floatini is also preprogrammed with mission proven firmware which I've made open source. Settings and telemetry data are dynamically configurable via CLI or radio link, and you can view live telemetry data in your browser (no internet connection required!). If you want to attach more sensors,the firmware is easily modified to include additional datapoints.Floatini provides a reliable, tested platform to launch your own high altitude balloon without breaking the bank. If you'reinterested in all the nitty-gritty hardware and softeware details that have gone into this project, check out the Hackaday page here.

How does it work?
--------------------------------
Launching your own high altitude balloon with Floatini is designed to be as simple as possible. All you need to sucessfully track your balloon is Floatini V2 Nano plus a groundstation, which can be a T-Beam board or a second Floatini. Floatini's communication protocol also allows for redundant ground receivers in case one fails. 

Hardware Features:
- Lightweight: 11g
- Optional balloon release mechanism
- Uses AA Lithium battery as power source
- 915MHz long range LoRa transceiver with TCXO
- High performance Ublox MAX-M10 GPS receiver
- Integrated omnidirectional GPS antenna
- DPS310 barometric pressure sensor
- 3 axis accelerometer detects descent and landing
- QWIIC connector for adding external sensors
- Piezo buzzer to make post-landing location easier
- 4 temperature sensors
- 8 hours of continuous data logging (1sec interval)    
- Battery voltage and current reporting
- Firmware updates via micro USB connector
- U.fl LoRa antenna connector
- 4 status LEDs make troubleshooting easier
- SWD pads for programming/debuggingSoftware Features
- Pre-launch configuration via CLI or browser
- Configure on the fly via LoRa link
- View live telemetry data in browser (no internet connection)
- Support for external QWIIC sensors (work in progress)
- Adaptive telemetry protocol reduces risk of losing payload
- Flexible ground station setup
- Supports redundant ground station receivers
- Configuration settings persist across reboot